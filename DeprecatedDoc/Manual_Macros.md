[Back to Index](DeprecatedDoc/CLAMUserManual "wikilink")

We define a set of C preprocessor macros that pollute the global namespace, so we document them here explicitly, for minimizing the possibility of macro names clashes. Some of them are global flags that affect the entire library behaviour, some other are part of the DynamicType API, a few needed for ensuring cross-platformness (especially math constants) and some macros that give support to Defensive programming techniques. Besides, we also rely on some macros to be defined by the compiler or development environment, to select a particular behaviour for a given platform.

Global flags
============

TODO Should be moved

You can define these macros in the project (VisualC++) or makefile (GNU) in order to change CLAM behaviour.

`   * CLAM_EXTRA_CHECKS_ON_DYNAMIC_TYPES`
`     Define it to perform paranoid very very slow checks on dynamic types.`
`   * CLAM_USE_STL_ARRAY`
`     Define it to use the CLAM::Array implementation based on the STL std::vector`

Cross-platformness macros
=========================

These macros can be used inside user code.

`   * PI`
`     PI number in double precission`
`   * TWO_PI`
`     Two times PI number in double precission`

Dynamic Types Macros
====================

All these macros are more accurately documented in Dynamic Types reference.

`   * DYNAMIC_TYPE(newClass, nAttributes)`
`     Insert it inside a DynamicType subclass definition in order to generate some macro expanded functions.`
`   * DYNAMIC_TYPE_USING_INTERFACE(newClass, nAttributes, subClass)`
`     Insert it inside a DynamicType descendant class definition in order to generate some macro expanded functions.`
`   * DYN_ATTRIBUTE(order, access, type, name)`
`     Inside a dynamic type class definition, it defines a dynamic attribute. See Dynamic Types.`
`   * DYN_CONTAINER_ATTRIBUTE(order, access, type, name,elemName)`
`     Inside a dynamic type class definition, it defines a dynamic attribute with STL container like interface. See Dynamic Types.`
`   * CLAM_TYPE_INFO_GROUP(group, class)`
`     Defines the class CLAM type information like the one defined in the group. (ie. BasicCTypeInfo, ContainerTypeInfo...) See DynamicType-XML`

Defensive programming macros
============================

Although some may consider an oxymoron to use C preprocessor macros for defensive programming they are very useful for giving users enough flexibility to enable or disable code auto-checking:

`   * CLAM_ASSERT(expressionToBeTrue, messageWhenFalse)`
`     A normal CLAM assert. See Error handling.`
`   * CLAM_BEGIN_CHECK`
`     Marks the start of check related code. See Error handling.`
`   * CLAM_END_CHECK`
`     Marks the end of check related code. See Error handling.`
`   * CLAM_DEBUG_ASSERT(expressionToBeTrue,messageWhenFalse)`
`     A debug only CLAM assert. See Error handling.`
`   * CLAM_DEBUG_BEGIN_CHECK`
`     Marks the start of debug only check related code. See Error handling.`
`   * CLAM_DEBUG_END_CHECK`
`     Marks the end of debug only check related code. See Error handling.`
`   * CLAM_BREAKPOINT`
`     Sets a compiler independent execution breakpoint.`

preinclude.hxx Macros
=====================

These macros deal with system dependant issues and are defined (or not) in the src/Defines/{platform name}/preinclude.hxx file. This file is generated by GNU autoconf on UNIX platforms, and is hardcoded for specific platforms such as Microsoft Windows.

`   * HAVE_NON_COMPLIANT_STANDARD_LIBRARY`
`   * HAVE_STANDARD_VECTOR_AT`
`   * HAVE_STANDARD_SSTREAM`
`   * HAVE_STANDARD_SSTREAM_STR`
`   * CLAM_BIG_ENDIAN`
`   * CLAM_LITTLE_ENDIAN`

Platform dependant macros
=========================

CLAM code expects these macros to be defined by the compiler in order to identify the platform and the compiler:

`   * _MSC_VER`
`     This macro is defined by Microsoft Compilers, and identifies the major and minor version of the compiler being used.`
`   * __MWERKS__`
`     This macro is defined by Metrowerks Codewarrior family of compilers`
`   * __GNUC__`
`     This macro is defined by all recent versions of the GNU C/C++ Compiler`
`   * WIN32`
`     This macro is defined by default by Microsoft Visual Studio IDE. If your IDE is not defining it by default, and you are developing on Microsoft Windows you should hack your makefiles ( or similar ) since it is vital for some CLAM cross-platform functionalities to work properly.`
`   * macintosh`
`     When this macro is defined CLAM code assumes that the current platform is some MacOS version.`
`   * POSIX`
`     The generated binary is for a POSIX compatible operating system (i.e. headers such as unistd.h are expected to be found).`

Private Macros
==============

Those macros are not intended for user use. They are documented here only for completeness.

`   * CLAM_NUMERIC_ARRAY_INITIALIZATIONS(type)`
`   * CLAM_FAST_ARRAY_SPECIALIZATIONS(type)`
`   * CLAM_DB_SCALING`
`   * CLAM_ABORT(message)`
`   * __COMMON_DYNAMIC_TYPE(CLASS_NAME,N)`
`   * __COMMON_DYN_ATTRIBUTE(N,ACCESS,TYPE,NAME)`
