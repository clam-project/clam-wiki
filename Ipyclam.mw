== Introduction ==

'''Python''' is a popular language. Flexible, expressive and fast for development. But by its nature it is not appropiate for doing real-time processing. Eventhough, you can use real-time ready modules in fast and real-time safe C++ and combine them using Python expressiveness.

'''ipyclam''' is a python module that wraps CLAM by providing the interface to do the same actions you could do with the NetworkEditor by connecting several CLAM modules playing them. It also provides means for binding Qt interfaces, like you would do with the Prototyper, but with the addition of being able to build and add python logic by means of PyQt or PySide.
So ipyclam enpowers the kind of prototypes you could build with NetworEditor/Prototyper.

To get a feeling of the kind of things you can do with ipyclam lets see some examples.
To play a file in a loop with ipyclam:

 import ipyclam
 n=ipyclam.Network()
 n.file = n.types.MonoAudioFileReader
 n.out = n.types.AudioSink
 n.file.Loop = 1
 n.file.SourceFile = "jaume-voice.mp3"
 n.file > n.out
 
 n.backend="PortAudio"
 n.play()

And if you want to bind QT interface to display an oscilloscope:

 from PyQt4 import QtCore, QtGui
 a=QtGui.QApplication([])
 
 w=n.createWidget("Oscilloscope")
 w.show()
 w.setProperty("clamOutPort", "file.Samples Read")
 
 n.stop()
 n.bindUi(w)
 n.play()


You can also load an UI file and bind it simultaneously..

 w2 = n.loadUi("myui.ui")
 w2.show()
 n.stop()
 n.bindUi(w2)
 n.play()

Adding a tonal analysis and some related views

 n.stop()
 n.tonal = n.types.TonalAnalysis
 n.file > n.tonal
 w3 = n.createWidget("CLAM::VM::KeySpace")
 w3.setProperty("clamOutPort", "tonal.Chord Correlation")
 n.bindUi(w3)
 w3.show()
 n.play()

The following sections describe in detail ipyclam API.
The API is ruled by the following principle:
to provide the most convinient API of doing things,
even if it is not general enough to express every case,
but then, provide a less convenient but more general API that can be used for those specific cases.

So there are several ways of doing things, like accessing connectors, connectiong or configuring processings.
The following sections provide a summary of the API for several operations.

== Creating processing modules ==

Given a network:

 n = ipyclam.Network()

you can create the network by assigning a property to a string:

 n.myprocessing = "AudioSink"

In this case ''myprocessing'' is the name of the created module and 'AudioSink' the type.

You can see the xml version of this module:
 n.xml()

Or you can dump python code to build it again:
 n.code()

What if I want to name the processing with spaces such 'My Processing 2'?
In this case we can use the subscript interface, which is more verbose but can deal with spaces.

 n['My Processing 2'] = "AudioSink"

Subscript interface is also the solution when you deal with attributes and methods that are already in the network
such as 'xml' and 'code'. Use dir(n) to see all of them.

If you are using an interactive python interpret such as ipython or bpython,
you can explore the network with the tab key.

 n.[tab]

And you will see the attributes and methods available included the processing you already added to the network.

These principle extends to other levels.
* You can explore a processing for ports, cotrols and configuration parameters.
* You can access them as attributes or if there is some collision or the name is not a valid identifier, you can use the subscript interface.

Going back to processing creation, besides the string, 
you can also use the 'types' network attribute which contains all the types as attributes:

 n.myprocessin3 = n.types.AudioSink

This also implies that you can explore the available types in interactive mode by doing:

 n.types.[tab]

== Configuring a processing ==

TODO
