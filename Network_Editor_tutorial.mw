CLAM's visual builder is known as the NetworkEditor.
It is a patching tool to graphically connect processing units in a ''network''
that you can use as the processing core of you application.
CLAM also provides Qt Designer integration,
so you can also build graphical interfaces that nicely interact with such processing core.
You can even combine both, Qt Designer and CLAM NetworkEditor,
to fully build standalone applications and plugins without writting any code at all.

In the present tutorial we will learn the main features of the NetworkEditor step by step.

== Setup ==

* Linux: the recommended audio backend is JACK. It is automatically selected if the JACK server is running. Use qjackctl to start it and use the 'Connect' tool to connect inputs and outputs as desired.
* Windows: we recommend the PortAudio backend which is selected by default. You should select with the Windows Multimedia Mixer the input to fed to the NetworkEditor: 'microphone' or 'mixed stereo' when you want to process the audio output of other program such a multimedia player. '''To prevent annoying feedback noise, do not use the 'mixed stereo' when the network has also output.'''

== A quick example of the workflow ==

To see the power of the CLAM Network Editor let's start by taking a look at one of the provided example
and following the normal workflow.

* Start the NetworkEditor. You will see an empty canvas like this:
[[Image:NetTutorial-Initial.png|500px|center]]
* Check that you can see the icon of the recommended audio backend for your platform at the lower right corner.
* Choose the menu option ''File->Open example''
* Select the network file named <tt>SMSTransposition.clamnetwork</tt>.
* Resize the window and use the zoom buttons [[Image:NetTutorial-ZoomOut.png]] or the mouse wheel to make the network fit:
[[Image:NetTutorial-SMSTransposition.png|500px|center]]
* Setup your platform so that you get the input from the microphone and the output goes to the speakers.
* Press the space key or the Play [[Image:Icon-Play.png]] button to start the network.
* Talk to the microphone while moving both sliders. You will see something like this.
[[Image:NetTutorial-SMSTranspositionPlaying.png|500px|center]]
* After playing a little, stop it by pressing the Esc key or the Stop [[Image:Icon-Stop.png]] button to stop the effect

That network will be the core of our application.
We need an interface, we can build it using the Qt Designer.
The Qt Designer is a free software tool that is part of the Qt development framework from Trolltech. You can graphically build user interfaces. CLAM provides a plugin that enables some CLAM related plugins to be used in such interfaces.
We'll take an already done interface but let's see how does it looks like with Qt Designer.

* Run Qt Designer
** Windows: There is an icon on the same Start menu folder where the Networkeditor is.
** Linux: Run the command <tt>designer-qt4</tt>.
[[Image:NetTutorial-DesignerInterface.png|500px|center]]
* Assure that the CLAM Widgets group is available at the end of the Widget Box on the left. This group contains CLAM provided widgets that can be linked to the network processings (and what if it is not? copy libCLAMWidgets.so to /usr/lib/qt4/plugins/designer/ .).
[[Image:NetwEditQt4-PluginWidgetsIcons.png|200px|center]]
* Load the file <tt>SMSTransposition.ui</tt> from the NetworkEditor examples folder.
[[Image:NetTutorial-SMSTranspositionInterface.png|500px|center]]
* Check on the 'Object Inspector' that some of the widgets names are related to the processings names on the former network. This is what we use to bind the interface elements to the processing elements. You can obtain such name by using the 'Copy connection name' option on the connectors context menu.
[[Image:NetEditQt4-ConnectorsContextActions.png|center]]

Now that we have an interface, let's run it with the Prototyper.
The Prototyper is an application that loads both, the CLAM network and the Qt interface and run its as it were an standalone application.

* Windows: you may need to close the NetworkEditor, if you didn't before, to free the devices.
* Run the Prototyper from the Start menu.
* You will be asked to choose a network to run, so choose <tt>SMSTransposition.clamnetwork</tt>.
* After some initialization this application will appear:
[[Image:NetEditQt4-Prototyper-Peaks.png|500px|center]]
* Linux: after the application starts, you will need to connect properly the inputs and outputs as you did with the NetworkEditor.

Feel free to try other provided examples both with the Prototyper and the NetworkEditor. There is no problem running networks without interface because Prototyper will provide a default one.

[[Image:NetEditQt4-PrototyperIndicators.png|center]]

== Creating the simplest Network ==

Now we know the workflow, but we are cheating because we took already done networks. So let's build a network from scratch, the simplest one.

* Select File->New on the NetworkEditor. You will get a blank canvas again.
* Now we are going to add a number of Processings. A Processing object is the basic building block in CLAM. Processings are listed on the left hand menu in the NetworkEditor, grouped by categories. Click on the Audio File I/O Category in order to expand the view and see what Processings are available.


[[Image:Tutorial-AudioFileProcessingTree.png|200px|center]]


* Click on the MonoAudioFileReader and drag it to the canvas on the right side. It should now look like this:


[[Image:MonoAudioFileReader.png|500px|center]]


* The Processing is "red" because it is not "configured" properly. If any Processing in the network is not properly configured, the network cannot be started. Let's fix that. Pass over the processing with the mouse and a tooltip will show the configuration error message. In this case, we did not selected a file to read.

[[Image:NetTutorial-ErrorTooltip.png|200px|center]]

* Processing configuration is accessible from the popup menu that appears when you right-click the processing.

[[Image:NetTutorial-ProcessingPopupMenu.png|300px|center]]

* Choose 'Configure' and it will open a configuration dialog.

[[Image:NetTutorial-AudioFileConfig.png|500px|center]]


* Click on the "..." button and select an audio file from your hard drive.
* Assure you have the 'Loop' option also selected.
* After clicking ok on the configurator, the Processing should be in Green now.

[[Image:NetTutorial-MonoAudioFileReaderConfigured.png|500px|center]]


* Now you can run this network by simply selecting Network->Play. All you can see is that the Playback status down on the right says ''Playing'' but no sound is produced. That is because we have still not added an audio output!
* Go to the ''Audio Input/Output'' category and drag an AudioSink processing object.
* To connect both processings just drag a wire from one round connector (port) to the other.

[[Image:NetTutorial-ConnectedProcessings.png|500px|center]]

* Port connection is not allways feasible. Ports communicate data of several types of data. You can not connect ports which do not share its data type. While dragging a wire, ports that are not compatible are highlighted in red instead of green.

[[Image:NetEditQt4-ForbidenDrop.png|200px|center]]
[[Image:NetEditQt4-AllowedDrop.png|200px|center]]

* To disconnect a port, use the context menu for the connector (right click the port).

[[Image:NetTutorial-PortPopupMenu.png|500px|center]]


* Reconnect the ports and play the network. You will hear the sound file you selected.

== Visualising data ==

* Another interesting thing we can add to our network is a visualisation of the audio that is being played. For that purpose we will use the Oscilloscope in the 'Graphiclal Monitors' category. Graphical monitors are an special kind of processing that displays incoming data.
* Data is displayed in the box. As it is too small you need to resize it by dragging the lower right yellow corner. You can also move the processing by dragging the name caption.
* Connect the input Port of the Oscilloscope to the output Port of the MonoAudioFileReader. Start the Network, you should be able to see the audio being read:

[[Image:NetTutorial-AudioMonitor.png|500px|center]]

* Right now we only can use audio monitors. Later on we'll see other types of data that can be also viewed.

== Saving and loading ==

* We have put too much work into this network just to risk loosing it now! We should save it somehow. Select File->Save and choose the location and name you want. Don't forget the '.clamnetwork' extension.
*If you are wondering what the file looks like go ahead and open it with your favourite text editor. Note that it is a regular xml file that is easy to edit and export and should look something like this:

[[Image:NetworkConfig.png|500px|center]]

This file specifies all the Processings, connections and configurations. Note that the graphical positions of the elements are stored in a separate .pos file.

*If you feel adventurous you can go ahead and edit some of the values and then load the xml from the NetworkEditor.


==The Spectral Domain==

* In order to do more interesting things we will now turn into the spectral domain. We can analyze the audio signal to obtain an spectrum, a frequency domain representation of the signal. The spectrum can be modified in a wiser way than time domain audio signal and then resynthesized back.

* So, delete the connection between MonoAudioFileReader and AudioSink. Drag a SpectralAnalysis from the Analysis category and a SpectralSynthesis and a OverlapAdd from the Synthesis category. Connect them as shown:


[[Image:NetTutorial-SpectralAnalysisSynthesisComplete.png|500px|center]]

* OverlapAdd is used for smoothing out the resulting audio frames.

* Now you need to configure the Processings appropiately. We won't go into the DSP details but you are more than welcome to try with different values (be careful to save the network every step you take because in its current version, a wrong setting will produce a program abortion).
Here you have a screenshot of the three configurations (SpectralAnalysis, SpectralSynthesis and OverlapAdd).


[[Image:SpectralAnalysisConfig.png|200px|center]]


[[Image:SpectralSynthesisConfig.png|200px|center]]


[[Image:OLAConfig.png|200px|center]]


* In order to finish this section we are going to add a couple of monitors that can give us more useful information. We will add an SpectrumView to the output of the SpectralAnalysis and reconnect the Oscilloscope to the output of the OverlapAdd, just as shown:


[[Image:NetTutorial-SpectralView.png|500px|center]]

* Note that you cannot connect the SpectrumView to any audio port.

==Transformations and Controls==

* Now that we know how to get exactly the same audio that we had at the beginning, how about playing around a bit with it? You can in fact select any transformation from the SpectralTransformations category, but in order to start small, we will use the SampleAndHold. Connect it as shown on the figure and add an SpectrumView to the output of the effect:


[[Image:NetTutorial-SampleAndHold.png|500px|center]]

* If you start the Network you will see its very clear effect! The spectrum is frozen on fixed intervals so you get a rhythmic artificial sound.

* But, how can I control the way the transformation behaves? Did you notice a red square on the top of the Processing? That is what in CLAM is called a "Control". Controls are used in order to receive and send asynchronous events (such as those coming from a slider,etc...). So all we need to do is to learn how to send values to this input control. Go to the Utils category and drag an OutControlSender.

[[Image:NetTutorial-ControlSender.png|200px|center]]

*Once in the canvas right click to bring up its configuration and set it up as shown below:


[[Image:SampleHoldControlConfig.png|300px|center]]


*Now connect the slider to the input control in the SampleAndHold and resize the control as needed. It should look like:


[[Image:ConnectingControl.png|500px|center]]

* Now you are ready to start the network and play around with the slider in order to affect the way the effect behaves.

* Finally it is up to you to try out the different Spectral Transformations and see what they are capable of doing. Not that you can even chain different transformations one after the other.
* The spectralTransformation.clamnetwork example is an effect chain consisting on: a three band filter, a robotization effect and a OscillatingSpectralNotch which amplifies an oscillating band of frequencies.

[[Image:NetTutorial-SpectralTransformation.png|500px|center]]

= Building Interfaces with the Prototyper =

As we saw at the beginning of the tutorial,
the Prototyper is a utility that wraps a network definition
under an interface to build an stand alone application.
The interface can be prototyped visually so 
'''no compilation, and no programming is involved.'''

Interfaces can be designed with a nice tool, the Qt Designer, 
which comes with the QT library by Trolltech.
Designer is used to layout graphical elements (widgets) on an interface.
Those includes some widgets that CLAM provides to visualize sound 
related data and control the processing.

Widget names are used to relate the processing and the interface elements. 
At the NetworkEditor, you can use contextual menus for ports and controls  to get the binding names for the widgets you want to attach.

Name bindings:

* InControl__<em>ProcessingName</em>__<em>InControlName</em>:
:  For sliders and knobs, sends integer numbers to the in control
* InControlFloat__<em>ProcessingName</em>__<em>InControlName</em>
:  The same as the previous one but sends double by dividing by 100
* InControlBool__<em>Processing</em>__<em>Control</em>: 
:  For check buttons (Radio buttons, check boxes or 
* AudioFile__<em>ProcessingName</em>:
:  Binds buttons with MonoAudioFileReaders, on click opens a file selection dialog.
* PlayButton:
:  Starts the network on click
* StopButton:
:  Stops the network on click
* BackendIndicator
:  To be bound to a Label. It adds a indicator of which backend is used.
* PlaybackIndicator
:  To be bound to a Label. It adds a indicator that says whether the network is playing.

When adding the names, you must change any space into a triple underline.

== Getting the default interface ==

Let's take a simple file player network such as the one we had at the first steps of the tutorial. The one with a MonoAudioFilePlayer and an AudioSink. Assure that the audio file is properly configured and save the network as <tt>MyFilePlayer.clamnetwork</tt>.

TODO: Screenshot for the network

If we start the network with the Prototyper, we'll get a simple interface that is provided by default.

TODO: Screenshot for the default prototype

== Building the default interface ourselves ==

Let's reproduce the same interface by our own.

* Open the designer and create a new dialog without buttons.
* Drag and drop three push buttons from the widget box to the dialog.
* Double click each one to change the text to 'Play', 'Stop' and 'Close'
* Click on the dialog to clear the selection and press the 'Lay Out Vertically' icon [[Image:Icon-LayOutVertically.png]] to have the buttons stacked.
* You can try the interface (without network) by pressing Ctrl-R
* Resize the dialog: the lay out makes the widgets to be organized properly whatever the dialog size
* Let's add some behaviour. Press the 'Edit Signal/Slots' button [[Image:Icon-EditSignalSlot.png]] to get into that edition mode.
* Drag a connection from the stop button to the dialog background.
* A dialog will pop up. Select the 'clicked()' signal to the 'close()' slot and accept.
* This way we are saying that whenever the 'Close' button is clicked the dialog will be closed. Go back to the 'Edit widgets' mode [[Image:Icon-EditWidgets.png]].
* Save the dialog in the same folder than the network as <tt>MyFilePlayer.ui</tt>. Note that the file names match but the extension.
* Now call the Prototyper and choose the network again. Our new interface is shown now. Perfect but we miss the Play and Stop functionalities. Let's add them.
* Right click the Play button and choose 'Change objectName...' and name it 'PlayButton'.
* Do the same with the Stop button and name it 'StopButton'.
* Save and launch again the prototyper. The Prototyper has identified the buttons names and now we can control the playback with them. Great!
* Now, the only way to know whether the network is playing or not is by listening. We can drop a Label into the dialog and name it 'PlaybackIndicator'. If we save it and launch the prototyper again, we'll see that Prototyper fills the label with the playback status.
* A different label but named 'BackendIndicator' would show the audio backend (Jack, PortAudio, VST...) in a similar fashion.

== Controlling the layout ==

At this point we have the same functionality that the default prototyper interface provides. As the interface is gonna get harder i recommand you to play a little with layouts before moving forward.

* Break the dialog layout [[Image:Icon-BreakLayOut.png]]
* Select a pair of buttons and click 'Layout Horizontally' [[Image:Icon-LayOutHorizontally.png]]
* A red box is surrounding them now. Click again on the dialog and click 'Layout Vertically' [[Image:Icon-LayOutVertically.png]] to set the top level layout.
* You can combine such layouts to get complex designs. Splitters provide a similar way of stacking but enable the user to change the size proportions.

== Visualizing data ==

* Drag an Oscilloscope from the widget box. Resize the dialog if it has become just a line.

[[Image:NETutorial-OscilloscopeInserted.png]]

* Open the network with the NetworkEditor if you closed it.
* Right-click the output port of the MonoAudioFilePlayer and choose 'Copy Prototyper Name'.
* This puts the binding name on the clipboard.
* Go back and change the name of the Oscilloscope. Delete the old name and paste the clipboard content.
* Save and run the Prototyper. You will see the sounding wave instead of the static sinusoid that is shown on the designer.

[[Image:NETutorial-OscilloscopePlaying.png]]

Now let's tweak the oscilloscope properties to make it look nicer.
Use the property editor to set somethin similar to this:
* autofillBackground: true
* styleSheet: background-color: #aff;
* lineColor: just pick one by clicking on the color value

== We are still updating this tutorial to the 0.4.0 version ==

'''The rest of this tutorial still refers to the 0.3.X versions of the Network Editor. It is expected to be updated in short to the 0.4.X series. Although the interface has changes, you could still follow it as concepts are the same.'''


==SMS Transformations==

Besides the regular STFFT (Phase Vocoder) implementation, CLAM also has implemented the Sinusoidal plus Residual Model (a.k.a. SMS). That model identifies the sinusoids (the tonal part) on the spectral representation and substract them to get residual (the noisy part). By doing so, we can process both components separatelly so even more interesting transformations can be implemented with that model. 

Now that you have a working knowledge of the NetworkEditor the best you can do is to start off with an example. Open SMSMess.clamnetwork and experiment with it, changing the SMS Transformations for others in the same category.


[[Image:SMSFreqShiftGainsPlots.png|500px|center]]




To see its potential let's start opening with a example network named SMSmess.xml.

[[Image:Prototyper-DesigningTheNetwork.png|500px|center]]


What it does is mainly an SMS transfomation called PitchShift which shifts the Sinusoidal
component of the sound and keeps the Residual component. 
Independent gains are applied to both components.

There is also a prepared interface for this example network. 
It is named SMSmess.ui and it is placed on the examples folder.
Open it with the Qt Designer.


[[Image:Prototyper-Designer.png|500px|center|Qt Designer opening the example interface]]

Notice that there is a '''CLAM Plots''' tab on the widget toolbox on the left.
If you don't see that tab or if you don't se the black squares on the dialog, 
you are having problems with the CLAM qt plugins.
The CLAM Plots toolbox contains widgets that display CLAM objects such as
audio, spectrums, spectral peaks...


In order the Prototyper utility to know which widgets must to be connected to the network
you must name the widgets like the examples above:

For the port monitors <tt>OutPort__<em>ProcessingName</em>__<em>PortName</em></tt>.
Be carefull, elements are separated with <b>double</b> underlines here!


[[Image:Prototyper-BindingPortMonitor.png|500px|center|Binding a port monitor to an output port]]

Similar names goes to knobs and sliders: <tt>InControl__<em>ProcessingName</em>__<em>ControlName</em></tt>

[[Image:Prototyper-BindingInputControl.png|500px|center|Binding a slider to an input control in the network]]

You should name a button <tt>PlayButton</tt> 
and you may name other button <tt>StopButton</tt>.
The prototyper will use them to control the network playback.

Once you are done with the interface you can save it with the same base name 
and in the same location than the network editor.
Of course, this is the case of the example.
Then, you can drag the SMSmess.xml file to the prototyper icon 
and you will see the application working:

[[Image:Prototyper-Running.png|500px|center|Running the application]]


== Building Interfaces with the Prototyper ==

To see its potential let's start opening with a example network named SMSmess.xml.

[[Image:Prototyper-DesigningTheNetwork.png|500px|center]]


What it does is mainly an SMS transfomation called PitchShift which shifts the Sinusoidal
component of the sound and keeps the Residual component. 
Independent gains are applied to both components.

There is also a prepared interface for this example network. 
It is named SMSmess.ui and it is placed on the examples folder.
Open it with the Qt Designer.


[[Image:Prototyper-Designer.png|500px|center|Qt Designer opening the example interface]]

Notice that there is a '''CLAM Plots''' tab on the widget toolbox on the left.
If you don't see that tab or if you don't se the black squares on the dialog, 
you are having problems with the CLAM qt plugins.
The CLAM Plots toolbox contains widgets that display CLAM objects such as
audio, spectrums, spectral peaks...


In order the Prototyper utility to know which widgets must to be connected to the network
you must name the widgets like the examples above:

For the port monitors <tt>OutPort__<em>ProcessingName</em>__<em>PortName</em></tt>.
Be carefull, elements are separated with <b>double</b> underlines here!


[[Image:Prototyper-BindingPortMonitor.png|500px|center|Binding a port monitor to an output port]]

Similar names goes to knobs and sliders: <tt>InControl__<em>ProcessingName</em>__<em>ControlName</em></tt>

[[Image:Prototyper-BindingInputControl.png|500px|center|Binding a slider to an input control in the network]]

You should name a button <tt>PlayButton</tt> 
and you may name other button <tt>StopButton</tt>.
The prototyper will use them to control the network playback.

Once you are done with the interface you can save it with the same base name 
and in the same location than the network editor.
Of course, this is the case of the example.
Then, you can drag the SMSmess.xml file to the prototyper icon 
and you will see the application working:

[[Image:Prototyper-Running.png|500px|center|Running the application]]
