This is the CLAM development wiki.

''Please, prepend 'Devel/' to any development pages you create here.''

Some development pages are still at the [https://iua-share.upf.es/wikis/clam_draft| old CLAM development wiki].

* [[Development screenshots]] show last achievements on CLAM development branch.
* [http://clam.iua.upf.edu/testfarm Testfarm web] shows the last commits and build and tests status in different platforms in real-time.
* [[GSoC 2007]] Google Summer of Code 2007 pages

== Subversion access ==
Subversion tree contains CLAM libs and applications: NetworkEditor, Annotator, SMSTools and Voice2MIDI.
* Open and read-only 
 $ svn co https://iua-share.upf.edu/svn/clam/trunk clam
* Active CLAM developers can also obtain commit access. See [[rules for commit access]]

== Getting involved ==

To get involved with CLAM development:
* Subscribe to the [https://llistes.projectes.lafarga.org/cgi-bin/mailman/listinfo/clam-devel clam development mailing list].
* Contact other CLAM developers at the #clam channel of the FreeNode IRC network.
* Blog (occasionally) about CLAM and syndicate your feed in the [http://clam.iua.upf.edu/planet clam planet].
* Fill bugs in our [http://clam.iua.upf.edu/bugreporting.html bug tracking tool].
* Fix bugs and send a [[#Prepare and apply a patch|patch]] ;-)
* Send some good patches and get [[Rules_for_commit access|svn commit access]]

== HOWTO's ==

* [[Devel/Changelog release policy]]
* [[Devel/Compile and install troubleshooting]]
* [[Devel/Mac OSX build]]
* [[Devel/Linux Gentoo build]]
* [[Devel/Windows build]] with MS Visual Studio 2005 (obsolete)
* [[Devel/Windows MinGW build]] (under development)
* [[Devel/Windows MinGW cross compile]] (the one working now for windows)
* [[Devel/Eclipse]]
* [[Devel/Testing processing algorithms]]
* [[Devel/CLAM idioms]] C++ techniques we use over and over.

== Tasks ==

* [[Devel/Release task list]]
* [[Devel/Current release TODOs]] short-term tasks.
* [[Devel/Plugins TODOs]] short and mid-term tasks.
* [[Devel/Ladspa Plugins TODOs]] short-term tasks. Mostly taken by Andreas Calvo.
* [[Devel/Faust integration TODOs]] short-term tasks. Mostly taken by Andreas Calvo.
* [[Devel/Web TODOs]].
* [[SoC ideas]]
* [[Devel/Annotator TODO's]] includes GSoC project tasks taken by Wang Jun
* [[Devel/NetworkEditor TODO's]]
* [[Devel/Infrastructure Refactoring TODO's]]
* [[Devel/Spectral Transformations TODOs]] GSoC project tasks. Mostly taken by Hern√°n Ordiales
* [[Devel/Real-Time Spectral Model Synthesizer]] GSoC project tasks. Mostly taken by Greg Kellum
* [[Devel/Chord Extraction TODO's]] includes GSoC project tasks taken by Pawel Bartkiewicz

== Prepare and apply a patch ==

We only give write access to the repository to developers with experience with clam development. But this not a problem since you can always send a patch to the devel-list, and clam-devs will take care of it (and we use to be quick).

We like receiving patches very much. Please do it even for very small things like improving the INSTALL file, or grammar corrections in the code comments. (So imagine how we like receiving bug-fixes!).
Luckily, working with patches in subversion is very easy:

* How to create a patch with your local modifications?
: Change dir to the '''root of your svn tree''' (the directory containing CLAM/ and NetworkEditor/, etc.) and do 
: <pre>$ svn diff > good-description.patch</pre>

* How to apply a patch (that maybe somebody posted to the list)?
: Change dir to the root of your svn tree and do
: <pre>$ patch -p0 < the.patch
</pre>

We prefer the patches being sent to the '''clam-devel mailing list'''. The issue tracker will be used when patches can not be applied (or discarded) immediately and need to remain on hold for some time.

== Pass the automatic tests ==

Checkout the clam test-data repository:

 $ svn co https://iua-share.upf.edu/svn/clam-test-data/trunk clam-test-data


Change dir to CLAM/test and compile with '''scons''' providing the following options (no installation step is needed):
* clam_prefix --which is the prefix where you installed clam. /usr/local by default
* test_data_path --the path to the clam-test-data sandbox (local copy of the repository).
For example:
 $ scons clam_prefix=~/local test_data_path=~/clam-test-data
Then execute unit and functional tests:
 $ ./UnitTests/UnitTests
 $ ./FunctionalTests/FunctionalTests


== Hot Spots ==

Things that core developers are eager to address but still not being refined in small tasks. Of course they need discussion.

* Protocol allowing processings to let the network decide its (audio) port size. 
* Parameter propagation through the data-flow
* Recursive networks
* Static network scheduling (Maybe based on an recursive analysis starting from sinks)
* Ease Processing writing: not make a config attribute mandatory.
* Unify Do() return semantics. One solution is do it void Do()
* Spectrum refactoring: one class per representation (complex, mag-phase, ...)

== User / Developer Wish List ==
* 1. A plugin system - ability to use both VST and "CLAM proprietary" plugins to add new features without recompiling
* 2. The ability to write and read images (EG: .bmp, pbm, .png, etc.) of spectrums so that the image can be manipulated (EG: stretching, pinching, skewing) (like Metasynth http://www.uisoftware.com/MetaSynth/index.html) with graphic tools and then converted back into sound. See this link for spectrogram pictures http://en.wikipedia.org/wiki/Spectrogram_%28audio%29#Creating_sound_from_a_spectrogram . 
* -- Netpbm (http://netpbm.sourceforge.net/) has programs that can be used for realtime image manipulation (see http://netpbm.sourceforge.net/doc/directory.html#editors). 
* -- GIMP (www.gimp.org/) has extensive scripting ability (http://docs.gimp.org/en/gimp-scripting.html#id2615658) that can be used for realtime image manipulation.
* -- A Monitor with a Touchscreen (http://en.wikipedia.org/wiki/Touchscreen) (or just a graphics tablet :( ) would allow you to draw sounds with your fingers, convert the image (assumed to be a spectrogram) from image format to a sound that would then play in near realtime (you would want to be able to draw for 1 second (variable) and then have the picture (lines) played). Piano keys could be drawn on the screen and you would touch those spots to play and wiggle your fingers to wiggle the frequencies. "Gestures" would allow squishing, flipping, gliding etc ...
