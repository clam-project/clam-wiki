The current content is copy-pasted from a David mail "Re: faust status" in 11th July 2008. 
'''TODO: rephrase and reformat to proper documentation style.'''

== Method (and signals and slots) naming conventions ==

CLAM uses FirstLetterUpperCase names for methods
(although there is a underground trend to change that ;-) )
but when dealing with widgets and qt code adhere to the qt naming conventions
for methods and use firstLetterLowerCase.

Avoid the tendency shown in Annotator/vmqt that rewrittes an uppercase
'Show' that calls a lower case qt 'show' method.

In general the conventions for slots and signals are:
* Signals: <tt>somethingHappened()</tt>   (using past)
* Slots: <tt>doThatThink</tt>   (imperative, just like a regular method)
so that when you connect you can read:
''When emmiter somethingHappened receiver doThatThing''

Reserve the onSomethingHappened method names for [http://doc.trolltech.com/4.4/designer-using-a-component.html#automatic-connections|ui implicitly connected slots] 
which follow qt naming conventions: <tt>on_uiObjectName_signalName()</tt>
Defining such a method saves you writting that connection code:

 connect(_ui->uiActionName, SIGNAL(triggered()), this, SLOT(doThat()))

== Deciding whether to use signals slots or not ==

The signal/slot mechanism is powerful but can turn you code a jungle.
'''Don't over use it.'''
* has less compile time checks, 
* '''makes execution harder to trace''',
* adds signal resolution overhead. 

I highlighted the second reason.

When to add a signal? 
When the widget you are programming is generating events that
will be catch by '''widgets you don't have control over them'''.
By the 'avoid sigslot' principle, 
this means that you should want to know the widgets that 
would receive that signal and call a method on them.

A bad smell for this is the case of programming a widget and having:
 connect(this, signal, knownWidget, slot)
and some other method doing:
 emit signal()
The emision should be turn simply into:
 knownWidget->slot()
and the connection removed.


In this case, I don't know if you did so, but anyway is a good advice to 
anyone new (or not that new) to qt: avoid using the signal slot mechanism 
when the signal is not directly an user event but code you write, and you 
know who is the receiver object and the receiver method. New people to Qt get 
entusiastic with sigslot mechanism which is powerful but has less compile 
time checks, is hard to trace and adds signal resolution overhead. 
Annotator's vmqt is a good example on over use and it is a hell to understand 
it ;-)

Also I saw you are emiting slots or regular methods. Don't emit methods not 
being signals, just call them. If you call an slot within the class just call 
it like a regular function. Just emit signals, not slots neither regular 
methods.

== When to use designer and when to use code? ==

Use the designer for '''main window''' but just to include
'''actions, menus, toolbars and images'''.
'''Avoid inserting widgets''' or controling the layout.
Previous developments using the ui as base for the layout of the widgets in main window has rendered in a hardly mantainable code.

In the case of dialogs, use the designer freely as long as
the dialog content is not dynamic.

== Icons ==

* In a given application, place the icons in src/images/
* Include them in a src/images.qrc file in the :/icons/ path
* SVG format is preferred over PNG, mostly with non stock icons.
* For stock icons use the crystalsvg theme
* Write down the path of copied stock icons in src/images/origin.txt so that they could be updated as a whole when we change/update the theme.
