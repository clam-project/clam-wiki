A processing is one of the boxes you can connect on the NetworkEditor.
They perform a process on some input data and writes some output data.
Sources and sinks for a processing are InPort's and OutPort's.
Ports can be templated to any copiable data.
Ports cooperate with the flow control to move the data arround.

Although it is not the recommended way, 
you can also use the processing directly as a function passing
the data directly to the Do overload which has parameters.

Here is a minimal implementation of a processing object with a single input and a single output:


== MyProcessing.hxx ==

 #ifndef MyProcessing_hxx
 #define MyProcessing_hxx
 
 #include <CLAM/InPort.hxx>
 #include <CLAM/OutPort.hxx>
 #include <CLAM/Processing.hxx>
 #include <CLAM/NullProcessingConfig.hxx>
 
 // Those two configuration types could be the ones you choose.
 // Your own ones or any type already in CLAM.
 #include "MyInputDataType.hxx"
 #include "MyOutputDataType.hxx"
 
 class MyProcessing : public CLAM::Processing
 { 
 	CLAM::InPort<MyInputDataType> mIn;
 	CLAM::OutPort<MyOutputDataType> mOut;
 	typedef CLAM::NullProcessingConfig Config;
 public:
 	const char* GetClassName() const { return "MyProcessing"; }
 	MyProcessing(const Config & config=Config()) 
 		: mIn("My Input", this)
 		, mOut("My Output", this) 
 	{
 		Configure( config );
 	}
  
 	~MyProcessing() {}
 
 	// Configuration to the minimal expression
 	bool ConcreteConfigure(const CLAM::ProcessingConfig&)
 	{
 		return true; // I got proper configuration
 	}
 	const CLAM::ProcessingConfig& GetConfig() const
 	{
 		static Config config;
 		return config;
 	}
 	
 	bool Do()
 	{
 		bool result = Do(mIn.GetData(), mOut.GetData()); 
 		// Tell the ports this is done
 		mIn.Consume();
 		mOut.Produce();
 		return result;
 	}
 
 	bool Do(const MyInputDataType& in, MyOutputDataType& out)
 	{
 		// Your implementation
 	}
 };
 #endif // MyProcessing_hxx

== MyProcessing.cxx ==

Normally this file would contain the implementation of most of the method in the hxx but we inlined them all for the example.

Still what needs always be on the cxx file is the factory registration.

 #include "MyProcessing.hxx"
 #include <CLAM/Factory.hxx>
 
 static CLAM::Factory<CLAM::Processing>::Registrator<MyProcessing>
 	myProcessingRegistrator("MyProcessing");

== NetworkEditor/ProcessingTree.cxx ==

This step will eventually disappear.

In order to see the processing on the NetworkEditor you need to add it
to the list of processings at the ProcessingTree.cxx file.
