== MyProcessing.hxx ==

 #ifndef MyProcessing_hxx
 #define MyProcessing_hxx
 
 #include <CLAM/InPort.hxx>
 #include <CLAM/OutPort.hxx>
 #include <CLAM/Processing.hxx>
 #include <CLAM/NullProcessingConfig.hxx>

 // Those two configuration types could be the ones you choose.
 // Your own ones or any type already in CLAM.
 #include "MyInputDataType.hxx"
 #include "MyOutputDataType.hxx"
 
 class MyProcessing : public CLAM::Processing
 { 
 	CLAM::InPort<MyInputDataType> mIn;
 	CLAM::OutPort<MyOutputDataType> mOut1;
 	typedef NullProcessingConfig Config;
 public:
 	const char* GetClassName() const { return "MyProcessing"; }
 	MyProcessing(const Config & config=Config()) 
 		: mIn("My Input", this)
 		, mOut("My Output", this) 
 	{
 		Configure( config );
 	}
  
 	~MyProcessing() {}

 	// Configuration to the minimal expression
 	bool ConcreteConfigure(const CLAM::ProcessingConfig&)
 	{
 		return true; // I got proper configuration
 	}
 	const ProcessingConfig& GetConfig() const
 	{
 		static Config config;
 		return config;
 	}
 	
 	bool Do()
 	{
 		bool result = Do(mIn.GetData(), mOut.GetData()); 
 		// Tell the ports this is done
 		mIn.Consume();
 		mOut.Produce();
 		return result;
 	}
 
 	bool Do(const MyInputDataType& in, MyOutputDataType& out)
 	{
 		// Your implementation
 	}
 };
 #endif // MyProcessing_hxx

== MyProcessing.cxx


 #include "MyProcessing.hxx"
 #include <CLAM/Factory.hxx>
 
 // This puts the processing available to the factory by linking this file.
 // This object cannot be ever on the hxx file.
 static CLAM::Factory<Processing>::Registrator<MyProcessing>
 	myProcessingRegistrator("MyProcessing");
 

== NetworkEditor/ProcessingTree.cxx ==

This step is needed now but this may eventually disappear.

In order to see the processing on the NetworkEditor you need to add it
to the list of processings at the ProcessingTree.cxx file.
