A processing is one of the boxes you can connect on the NetworkEditor.
They perform a process on some input data and writes some output data.
Sources and sinks for a processing are InPort's and OutPort's.
Ports can be templated to any copiable data.
Ports cooperate with the flow control to move the data arround.

Although it is not the recommended way, 
you can also use the processing directly as a function passing
the data directly to the Do overload which has parameters.

Here is a minimal implementation of a processing object with a single input and a single output:

[[Image:MyProcessing.png|thumb|How the processing will look like on the NetworkEditor]]

<pre>
#ifndef MyProcessing_hxx
#define MyProcessing_hxx

#include <CLAM/InPort.hxx>
#include <CLAM/OutPort.hxx>
#include <CLAM/Processing.hxx>

// Those two configuration types could be the ones you choose.
// Your own ones or any type already in CLAM.
#include "MyInputDataType.hxx"
#include "MyOutputDataType.hxx"

class MyProcessing : public CLAM::Processing
{ 
	CLAM::InPort<MyInputDataType> mIn;
	CLAM::OutPort<MyOutputDataType> mOut;
public:
	const char* GetClassName() const { return "MyProcessing"; }
	MyProcessing(const Config& config = Config()) 
		: mIn("My Input", this)
		, mOut("My Output", this) 
	{
		Configure( config );
	}
 
	bool Do()
	{
		bool result = Do(mIn.GetData(), mOut.GetData()); 
		// Tell the ports this is done
		mIn.Consume();
		mOut.Produce();
		return result;
	}

	bool Do(const MyInputDataType& in, MyOutputDataType& out)
	{
		// Your implementation
	}
};

#endif // MyProcessing_hxx
</pre>

== MyProcessing.cxx ==

As the class methods get verbose, it is convenient to move the implementation to the cxx. To keep the example short and easy to follow and copy, we kept all the implementations on the hxx.

But, still, what needs always be on the cxx file is the factory registration.
 // Version up to 1.1.0
 #include "MyProcessing.hxx"
 #include <CLAM/Factory.hxx>
 
 static CLAM::Factory<CLAM::Processing>::Registrator<MyProcessing>
 	myProcessingRegistrator("MyProcessing");

 // Version beyond 1.1.0
 #include "MyProcessing.hxx"
 #include <CLAM/ProcessingFactory.hxx>
 static const char * metadata[] = {
 	"key", "MyProcessing",
 	"category", "Spectral Transformations",
 	0
 	};
 static CLAM::FactoryRegistrator<CLAM::ProcessingFactory, MyProcessing> registrator(metadata);


You can blindly copy and change 'MyProcessing' by the name of your actual class and the category.

But if you want to understand what it does, here comes an explanation:
Static objects like this one are constructed before the 
program's 'main' function is called.
The constructor of this one (FactoryRegistrator) just adds the Processing Factory 
instructions on how to create a MyProcessing object when you ask
for the label "MyProcessing".

== NetworkEditor/ProcessingTree.cxx ==

[[Image:MyProcessing-ProcessingTree.png|thumb|MyProcessing available at the end of the 'Spectral Transformations' group]]

In order to see the processing on the NetworkEditor processing list
you still need to add it to the list of processings at
ProcessingTree.cxx.

This step will eventually disappear as the Processing Factory
gets more sophisticated (when it gets grouping features).


    ....
    "SMSTranspose",
    "VowelResonator",
    0,
    "Spectral Transformations",  // Group name item after a 0
    "OscillatingSpectralNotch",
    "SpectralDelay",
    "Vocoder",
    "ThreeBandFilter",
    "Robotization",
    "SampleAndHold",
    "ThreeBandCompressor",
    "Peakalizer",
    "ThreeBandAM",
    "MyProcessing",         <- New
    0,
    "Utils",                   // This is the next group name
    "Fundamental2Control",
    ....
