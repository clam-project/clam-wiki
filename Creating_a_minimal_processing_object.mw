A processing is one of the boxes you can connect on the NetworkEditor.
They perform a process on some input data and writes some output data.
Sources and sinks for a processing are InPort's and OutPort's.
Ports can be templated to any copiable data.
Ports cooperate with the flow control to move the data arround.

Although it is not the recommended way, 
you can also use the processing directly as a function passing
the data directly to the Do overload which has parameters.

Here is a minimal implementation of a processing object with a single input and a single output:

[[Image:MyProcessing.png|thumb|How the processing will look like on the NetworkEditor]]


== MyProcessing.hxx ==

 #ifndef MyProcessing_hxx
 #define MyProcessing_hxx
 
 #include <CLAM/InPort.hxx>
 #include <CLAM/OutPort.hxx>
 #include <CLAM/Processing.hxx>
 #include <CLAM/NullProcessingConfig.hxx>
 
 // Those two configuration types could be the ones you choose.
 // Your own ones or any type already in CLAM.
 #include "MyInputDataType.hxx"
 #include "MyOutputDataType.hxx"
 
 class MyProcessing : public CLAM::Processing
 { 
 	CLAM::InPort<MyInputDataType> mIn;
 	CLAM::OutPort<MyOutputDataType> mOut;
 	typedef CLAM::NullProcessingConfig Config;
 public:
 	const char* GetClassName() const { return "MyProcessing"; }
 	MyProcessing(const Config & config=Config()) 
 		: mIn("My Input", this)
 		, mOut("My Output", this) 
 	{
 		Configure( config );
 	}
  
 	~MyProcessing() {}
 
 	// Configuration to the minimal expression
 	bool ConcreteConfigure(const CLAM::ProcessingConfig&)
 	{
 		return true; // I got proper configuration
 	}
 	const CLAM::ProcessingConfig& GetConfig() const
 	{
 		static Config config;
 		return config;
 	}
 	
 	bool Do()
 	{
 		bool result = Do(mIn.GetData(), mOut.GetData()); 
 		// Tell the ports this is done
 		mIn.Consume();
 		mOut.Produce();
 		return result;
 	}
 
 	bool Do(const MyInputDataType& in, MyOutputDataType& out)
 	{
 		// Your implementation
 	}
 };
 #endif // MyProcessing_hxx

== MyProcessing.cxx ==

As the class methods get verbose, it is convenient to move the implementation to the cxx. To keep the example short and easy to follow and copy, we kept all the implementations on the hxx.

But, still, what needs always be on the cxx file is the factory registration.

 #include "MyProcessing.hxx"
 #include <CLAM/Factory.hxx>
 
 static CLAM::Factory<CLAM::Processing>::Registrator<MyProcessing>
 	myProcessingRegistrator("MyProcessing");

You can blindly copy and change 'MyProcessing' by the name of your actual class.

But if you want to understand what it does, here comes an explanation:
Static objects like this one are constructed before the 
program's 'main' function is called.
The constructor of this one just add the Processing Factory 
intructions on how to create a MyProcessing object when you ask
for the label "MyProcessing".

Nasty details.

== NetworkEditor/ProcessingTree.cxx ==

[[Image:MyProcessing-ProcessingTree.png|thumb|MyProcessing available at the end of the 'Spectral Transformations' group]]

In order to see the processing on the NetworkEditor processing list
you still need to add it to the list of processings at
ProcessingTree.cxx.

This step will eventually disappear as the Processing Factory
gets more sophisticated (when it gets grouping features).


    ....
    "SMSTranspose",
    "VowelResonator",
    0,
    "Spectral Transformations",  // This item after the zero is the group name
    "OscillatingSpectralNotch",
    "SpectralDelay",
    "Vocoder",
    "ThreeBandFilter",
    "Robotization",
    "SampleAndHold",
    "ThreeBandCompressor",
    "Peakalizer",
    "ThreeBandAM",
    "MyProcessing",         <- New
    0,
    "Utils",                   // This is the next group name
    "Fundamental2Control",
    ....
