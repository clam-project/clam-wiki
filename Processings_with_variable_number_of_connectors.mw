Using dynamic ports is very useful if you want to work with multichannel files. Dynamic ports allow us to increase and decrease the number of ports whenever you want.

== Defining dynamic ports ==

First of all, we have to decide the class of Ports that we want to use. In this example we will use the AudioInPort and AudioOutPort classes, so it's necessary the following includes. However you can decide another port type if you want.

        ...
        #include <CLAM/AudioInPort.hxx>
        #include <CLAM/AudioOutPort.hxx>
        ...

We have to have a vector of AudioInPort or AudioOutPort instead of an unique AudioInPort or AudioOutPort. That's because we want to work with dynamic port and we don't know the number of ports that we will need.
So we can add this lines in the class declaration. It's also useful to have an attribute that we will save the number of channels that we need for each AudioPort.

        ...
        CLAM::InPort<AudioInPor> mIn;                      <--- OLD
        CLAM::OutPort<AudioOutPort> mOut;                  <--- OLD
        typedef std::vector<CLAM::AudioOutPort*> OutPorts; <--- NEW
        typedef std::vector<CLAM::AudioInPort*> InPorts;   <--- NEW
        OutPorts _outports;                                <--- NEW
        InPorts _inports;                                  <--- NEW
        unsigned _numberChannelsOut;                       <--- NEW
        unsigned _numberChannelsIn;                        <--- NEW
        ...

== Initialization == 

We know that at least we will have one port, so we can initialize the vector with one port. This initialization has been written in the ConcreteConfigure() method, but you can write it wherever you want.
( This code is for _inports vector, but it's the same for the _outports vector).

        if(_inports.empty())
        {	AudioInPort * port = new AudioInPort( "in1", this);
                port->SetSize(BackendBufferSize());
                port->SetHop( BackendBufferSize());
                _inports.push_back( port );
        }

For increase in number of ports, we have to create an AudioPort and put it in the vector. 
The following code shows how to create as number of AudioInPort as number of channels.
The condition is the number of channels has to be greater than the vector size.

        std::string nameInPort = "in";
        if ( _numberChannelsIn > _inports.size() )
        {
                for (int i=_inports.size()+1; i<= _numberChannelsIn; i++)
                {
                        std::ostringstream nameStream;
                        nameStream << nameInPort << i;
                        AudioInPort * port = new AudioInPort( nameStream.str(), this);
                        port->SetSize( BackendBufferSize());
                        port->SetHop(BackendBufferSize());
                        _inports.push_back( port );
                }
        }

== Deleting some items from the dynamic ports ==

The example below shows how to decrease in number of ports. We want to get a vector that will have as number of AudioPorts as number and channels, so we will delete the remaining items. The condition is that the vector size has to be greater than the number of channels.

        if ( _numberChannelsOut < _outports.size() )
        {
                for (unsigned i= _numberChannelsOut; i<_outports.size(); i++)
                        delete _outports[i];
                _outports.resize( _numberChannelsOut );
        }

== Removing all ports ==

For removing all the ports we have to delete all the items and tell the ports that the vector of AudioPorts is clear.

        if(!_outports.empty())
        {
                for(OutPorts::iterator itOutPorts=_outports.begin();itOutPorts!=_outports.end();itOutPorts++)
                        delete *itOutPorts;        					            
        }
         _outports.clear();
        // Delete ports from Processing (base class) register
        GetOutPorts().Clear();

== Using the dynamic ports ==

Within the Do method we can read or write the AudioPorts. We create a CLAM::TDATA* array for save the buffer of each channel. 

        CLAM::TData* channels[_numberChannelsOut];
        for (unsigned channel=0; channel<_numberChannelsOut; channel++)
                channels[channel] = &_outports[channel]->GetAudio().GetBuffer()[0];

Then we can set the values that we want in the Audio Buffers.

        const int portSize = _outports[0]->GetAudio().GetBuffer().Size();
        for(int i=0; i< portSize; i++)
                for(unsigned channel = 0; channel<_numberChannelsOut; channel++)
                        channels[channel][i] = value; 

Finally, we have to call the Produce method for the AudioOutPorts and the Consume method for the AudioInPorts.

        for (unsigned channel=0; channel<_numberChannelsOut; channel++)
                _outports[channel]->Produce();
        for (unsigned channel=0; channel<_numChannelsIn; channel++)
                _inports[channel]->Consume();
