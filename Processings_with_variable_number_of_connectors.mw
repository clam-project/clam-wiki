Using dynamic ports is very useful if you, for example, want to write a multichannel file reader. Dynamic ports allow us to increase and decrease the number of ports whenever you want.

== Defining dynamic ports ==

First of all, we have to decide the class of Ports that we want to use. In this example we will use the AudioInPort and AudioOutPort classes, so it's necessary the following includes. However you can decide another port type if you want.

        ...
        #include <CLAM/AudioInPort.hxx>
        #include <CLAM/AudioOutPort.hxx>
        ...

We'll use a vector of AudioInPort (or AudioOutPort) instead of an unique AudioInPort or AudioOutPort. That's because we want to work with dynamic port and we don't know the number of ports that we will need.
So we can add this lines in the class declaration. 

        ...
        CLAM::InPort<AudioInPor> mIn;                      <--- OLD
        CLAM::OutPort<AudioOutPort> mOut;                  <--- OLD
        typedef std::vector<CLAM::AudioOutPort*> OutPorts; <--- NEW
        typedef std::vector<CLAM::AudioInPort*> InPorts;   <--- NEW
        OutPorts _outports;                                <--- NEW
        InPorts _inports;                                  <--- NEW
        ...

== Initialization == 

In case we decide to have at least one port, we need to initialize the vectorin the ConcreteConfigure() method.
( This code is for _inports vector, but it's the same for the _outports vector).

        if(_inports.empty())
        {	AudioInPort * port = new AudioInPort( "in1", this);
                port->SetSize(BackendBufferSize());
                port->SetHop( BackendBufferSize());
                _inports.push_back( port );
        }

To increase the number of ports, we have to create an AudioPort and insert it in the vector. 
The following code shows how to create as number of AudioInPort as number of channels.
The condition is the number of channels has to be greater than the vector size.

        std::string nameInPort = "in";
        if ( _numberChannelsIn > _inports.size() )
        {
                for (int i=_inports.size()+1; i<= _numberChannelsIn; i++)
                {
                        std::ostringstream nameStream;
                        nameStream << nameInPort << i;
                        AudioInPort * port = new AudioInPort( nameStream.str(), this);
                        port->SetSize( BackendBufferSize());
                        port->SetHop(BackendBufferSize());
                        _inports.push_back( port );
                }
        }

== Deleting some items from the dynamic ports ==

The example below shows how to decrease in number of ports. We want to get a vector that will have as number of AudioPorts as number and channels, so we will delete the remaining items. The condition is that the vector size has to be greater than the number of channels.

        if ( _numberChannelsOut < _outports.size() )
        {
                for (unsigned i= _numberChannelsOut; i<_outports.size(); i++)
                        delete _outports[i];
                _outports.resize( _numberChannelsOut );
        }

== Removing all ports ==

For removing all the ports we have to delete all the items and tell the ports that the vector of AudioPorts is clear.

        if(!_outports.empty())
        {
                for(OutPorts::iterator itOutPorts=_outports.begin();itOutPorts!=_outports.end();itOutPorts++)
                        delete *itOutPorts;        					            
        }
         _outports.clear();
        // Delete ports from Processing (base class) register
        GetOutPorts().Clear();

== Using the dynamic ports ==

Within the Do method we can read or write the AudioPorts. We create a CLAM::TData* array for save the buffer of each channel. 

        CLAM::TData* channels[_numberChannelsOut];
        for (unsigned channel=0; channel<_numberChannelsOut; channel++)
                channels[channel] = &_outports[channel]->GetAudio().GetBuffer()[0];

Then we can set the values that we want in the Audio Buffers.

        const int portSize = _outports[0]->GetAudio().GetBuffer().Size();
        for(int i=0; i< portSize; i++)
                for(unsigned channel = 0; channel<_numberChannelsOut; channel++)
                        channels[channel][i] = value; 

Finally, we have to call the Produce method for the AudioOutPorts and the Consume method for the AudioInPorts.

        for (unsigned channel=0; channel<_numberChannelsOut; channel++)
                _outports[channel]->Produce();
        for (unsigned channel=0; channel<_numChannelsIn; channel++)
                _inports[channel]->Consume();
